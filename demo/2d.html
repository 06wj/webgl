<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>3d</title>
	<style>
		div,body,p{
			margin: 0;
			padding: 0;
		}

		body{
			background: #000;
		}

		#game{
			position:absolute;
			left:50%;
			top:50%;
			margin-left: -275px;
			margin-top: -200px;
			border:1px solid #999;
			background: #000;
		}
	</style>
</head>
<body>
	<canvas id="game"></canvas>
	<script>
	var gameWidth = 550;
	var gameHeight = 400;
	var gameHalfWidth = gameWidth * .5;
	var gameHalfHeight = gameHeight * .5;
	var canvas = document.querySelector("#game");
	canvas.width = gameWidth;
	canvas.height = gameHeight;
	var ctx = canvas.getContext("2d");

	var vx = 0, vy = 0;
	canvas.onmousemove = function(e){
		var x = e.layerX;
		var y = e.layerY;
		vy = (gameHalfWidth - x)/gameWidth * .1;
		vx = (gameHalfHeight - y)/gameHeight * .1;
	}

	var xhr = new XMLHttpRequest;
	xhr.open("GET","./plane.obj",true);
	xhr.onreadystatechange = function(e){
		if(xhr.readyState == 4 && xhr.status == 200){
			start(xhr.response);
		}
	};
	xhr.send();

	function start(data){
		var plane = new threeObj(data);
		setInterval(function(){
			plane.angX += vx;
			plane.angY += vy;

			ctx.clearRect(0, 0, 550, 400);
			plane.render();
		}, 16);
	}

	function threeObj(data){
		this.angX = 0;
		this.angY = 0;
		this.points = this.parseObjData(data);
	}

	threeObj.prototype = {
		constructor:threeObj,
		parseObjData:function(str){
			var points = [];
			var varr = str.match(/[\r\n](v\s[\S\s]+?)\send\s/g);

			varr.forEach(function(v){
				var isSurface = v.indexOf("surf ") > -1;
				v = v.replace(/cstype[\s\S]+end\s/, '').replace(/^\s/, "").replace(/v\s/g, "[").replace(/[\r\n]+/g, "],").replace(/[\s]/g, ",");

				v = "[" + v.slice(0, -1) + "]";
				v = JSON.parse(v);
				if(isSurface){
					var last = v[3];
					v[3] = v[2];
					v[2] = last;
				}
				points.push(v);
			});
			return points;
		},
		to2d:function(obj){
			var vpx = gameWidth * .5;
	    	var vpy = gameHeight * .5;
	    	var viewDistance = 1000;
	    	var perspective = viewDistance / (viewDistance - obj.z);
	        obj.x = vpx + obj.x * perspective;
	        obj.y = vpy + obj.y * perspective;
		},
		render:function(){
			var that = this;
			var points = this.points;
			ctx.lineWidth = 1;
			points.forEach(function(plane){
				ctx.beginPath();
				if(!plane.color){
					var color = Math.floor(Math.random()*0xffffff).toString(16);
					color = color.length == 6?color:"000000".slice(0, 6-color.length) + color;
					plane.color = "#" + color;
					// plane.color = "#fff";
				}
				ctx.strokeStyle = plane.color;
				// ctx.fillStyle = plane.color;


				plane.forEach(function(p, i, arr){
					var scale = 5;
					var a = {
						x:p[0] * scale,
						y:p[1] * scale,
						z:p[2] * scale
					};

					a = that.rotateX(a.x, a.y, a.z, that.angX);
					a = that.rotateY(a.x, a.y, a.z, that.angY);
					that.to2d(a);

					if(i == 0){
						ctx.moveTo(a.x, a.y);
					}
					else{
						ctx.lineTo(a.x, a.y);
					}

					// ctx.moveTo(a.x, a.y);
					// ctx.arc(a.x, a.y, 1, 0, Math.PI*2);
				});

				ctx.closePath();
				ctx.stroke();
				// ctx.fill()
			});
		},
		rotateX:function(x, y, z, ang) {
			return {
				x: x,
				y: y * Math.cos(ang) - z * Math.sin(ang),
				z: y * Math.sin(ang) + z * Math.cos(ang)
			};
		},
		rotateY:function(x, y, z, ang) {
			return {
				x: x * Math.cos(ang) + z * Math.sin(ang),
				y: y,
				z: z * Math.cos(ang) - x * Math.sin(ang)
			};
		},
		rotateZ:function(x, y, z, ang) {
			return {
				x: x * Math.cos(ang) - y * Math.sin(ang),
				y: x * Math.sin(ang) + y * Math.cos(ang),
				z: z
			};
		}
	};
	</script>
</body>
</html>
















